<section>
  <header>
    <div>
      <p class="deckTree">{{Deck}}</p>
      <p class="subDeck">{{Subdeck}}</p>
    </div>
  </header>

  <article>
    <div id="questionField" class="questionField">
      <div>
        <span class="tagGrayColor">Quantos parâmetros possui a função</span>
        <span class="functionColor" id="replacement">{{FunctionName}}()</span>?
      </div>
    </div>
  </article>

  <article class="articleAnswer hidden auto-hidden">
    <div class="notes">
      <div class="parametersQtd notesChild containerFlex" style="color: #4cc5a1">{{ParametersQuantity}}</div>
    </div>
    <div id="parameters" class="notes parameters" style="margin-top: 15px">
      <div class="notesChild containerFlex">{{Parameters}}</div>
    </div>
  </article>

  <article class="extraContainer image">
    {{#SampleImage}}
    <div class="extra" id="extraField">
      <div class="notesChild">{{SampleImage}}</div>
    </div>
    {{/SampleImage}}
  </article>
</section>
<script>
  $("div:has(ul)", "div:has(ol)").addClass("notesChild");

  var regex = /(?<parameter>[^:]*): (?<type>[^-]*)- \[(?<description>.*?)\]/g;
  var element = document.getElementById("parameters");
  function addClass(element) {
    let elementHTML = element.innerHTML.replace(/&nbsp;/g, " ");
    const result = [...elementHTML.matchAll(regex)].map((item) => ({
      element: `<span>
                  <span class="attributeColorCSS">${item.groups.parameter}</span>: 
                  <span class="classColor">${item.groups.type}</span> - 
                  <span class="tagGrayColor">${item.groups.description}</span>
                  </span>`,
      fullMatch: item["0"],
    }));
    result.forEach((c) => {
      elementHTML = elementHTML.replace(c.fullMatch, c.element);
    });
    element.innerHTML = elementHTML;
  }
  addClass(element);
</script>
<script>
  var replaceStringAndAddClass = (...elementsID) => {
    console.log("Hi");

    function customReplace(textElement, matches) {
      matches.forEach((c) => {
        var matches = [...textElement.matchAll(c.pattern)];
        matches.forEach((match) => {
          var value = match.groups[c.groupName];
          textElement = textElement.replace(value, `<span class="${c.className}">${value}</span>`);
        });
      });
      return textElement;
    }

    elementsID.forEach((elementID) => {
      var patterns = [
        {
          pattern: /(?<class>\w+)[.]\w+[.]\w+[(][)]/g,
          groupName: "class",
          className: "class-color",
        },
        {
          pattern: /(?<fix>\w+)[.]\w+[(][)]/g,
          groupName: "fix",
          className: "const-color",
        },
        {
          pattern: /(?<function>\w+)[(][)]/g,
          groupName: "function",
          className: "function-color",
        },
        {
          pattern: /(?<symbol>\?)/g,
          groupName: "symbol",
          className: "symbols-color",
        },
        {
          pattern: /(?<symbol>\!)/g,
          groupName: "symbol",
          className: "symbols-color",
        },
        {
          pattern: /(?<symbol>\()/g,
          groupName: "symbol",
          className: "symbols-color",
        },
        {
          pattern: /(?<symbol>\))/g,
          groupName: "symbol",
          className: "symbols-color",
        },
      ];

      var element = document.getElementById(elementID);
      var textElement = element.innerHTML.trim();
      textElement = customReplace(textElement, patterns);
      console.log(textElement);
      element.innerHTML = textElement;
    });
  };
  replaceStringAndAddClass("replacement");

  function typingJS(options) {
    const createStyle = () => {
      if (document.querySelector("typingStyle")) return;
      const css = `.hide-element-typing{opacity:0;font-size:20px}.show-element-typing{opacity:1;transition:opacity .3s;font-size:20px}.cursor-typing{position:absolute;color:transparent}.cursor-typing:before{content:".";width:4px;height:10px;background-color:green;color:green;animation:cursor .8s infinite}@keyframes cursor{0%{opacity:1}50%{opacity:0}100%{opacity:1}}`;
      const $style = document.createElement("style");
      $style.innerHTML = css;
      $style.id = "typingStyle";
      document.head.appendChild($style);
    };

    const processText = (element) => {
      let index = 0;
      const wrapChar = (char) => `<span class="hide-element-typing char">${char}</span>`;
      const replaceHtmlSymbols = (text) => text.replace(/&\w+;/g, (c) => wrapChar(c));

      const split = replaceHtmlSymbols(element.innerHTML).split("");

      const hasSplitElements = () => index < split.length;

      const skipTag = () => {
        const isNotTagOpening = () => split[index] != "<";
        const isTagClosing = () => split[index - 1] == ">";

        if (isNotTagOpening()) return;

        while (hasSplitElements()) {
          index++;
          if (isTagClosing()) break;
        }
      };

      const skipHtmlOpeningClosingSymbols = () => {
        const isNotHtmlOpeningTagSymbol = () => split.slice(index - 1, index + 1).join("") != ">&";

        const isNotHtmlClosingTagSymbol = () => split.slice(index - 1, index + 1).join("") != ";<";

        if (isNotHtmlOpeningTagSymbol()) return;

        while (hasSplitElements() && isNotHtmlClosingTagSymbol()) {
          index++;
        }
      };

      const processArray = () => {
        const isOpeningTag = () => split[index] == "<";

        while (hasSplitElements() && !isOpeningTag()) {
          split[index] = wrapChar(split[index]);
          index++;
        }
      };

      if (element.classList.contains("typing-ready")) return;

      element.classList.add("typing-ready");

      const steps = [skipTag, skipHtmlOpeningClosingSymbols, processArray];

      while (hasSplitElements()) {
        steps.forEach((stepFn) => stepFn());
      }

      element.innerHTML = split.join("");
    };

    function processHiddenElements(cursorElement, { timeSlow, timeTypingMs }) {
      let index = 0;
      const hiddenElements = [...document.querySelectorAll(".hide-element-typing")].filter((c) => c.innerText.length);

      const currentHiddenElement = () => hiddenElements[index];

      const calculateDelayTime = () => {
        const result = [
          {
            keyFn: () => index == 0,
            value: 400,
          },
          {
            keyFn: () => currentHiddenElement().innerText.trim().length == 0,
            value: 0,
          },
          {
            keyFn: () => currentHiddenElement().classList.contains(options.timeSlowClass),
            value: timeSlow,
          },
          { keyFn: () => true, value: timeTypingMs },
        ].find((truthy) => truthy.keyFn());

        return result.value;
      };

      const setCursorOnLastElementCharacter = () => {
        const lastElement = hiddenElements.filter((c) => c.classList.contains("char")).slice(-1)[0];

        lastElement.append(cursorElement);

        cursorElement.setAttribute("style", `top:auto;left:auto;position:relative;opacity:1`);
      };

      (function removeClass() {
        if (index == hiddenElements.length) {
          setCursorOnLastElementCharacter();
          options.callback();
          return;
        }

        let time = calculateDelayTime();

        setCursorPosition(currentHiddenElement(), cursorElement);
        currentHiddenElement().classList.add("show-element-typing");

        setTimeout(() => {
          index++;
          removeClass();
        }, time);
      })();
    }

    const setCursorPosition = (element, cursorElement) => {
      const offsetY = 2 + window.scrollY,
        offsetX = 8 + window.scrollX;

      if (!element.classList.contains("char")) return;

      const { x, y } = element.getBoundingClientRect();

      cursorElement.setAttribute("style", `top:${y + offsetY}px;left:${x + offsetX}px;opacity:1`);
    };

    const setClassDeepElements = (element, tagNames) => {
      for (let child of element.children || []) {
        setClassDeepElements(child, tagNames);
      }

      element.classList.contains("hide-element-typing") === false && element.classList.add("hide-element-typing");
      element.classList.contains("show-element-typing") && element.classList.remove("show-element-typing");

      tagNames.includes(element.tagName) && element.classList.add("char");
    };

    createCursor = () => {
      const cursor = document.createElement("span");
      cursor.classList.add("cursor-typing", "hide-element-typing");
      cursor.innerText = ".";
      document.body.append(cursor);
      return cursor;
    };

    getCursor = () => {
      const cursor = document.querySelector(".cursor-typing");
      cursor && cursor.parentNode.removeChild(cursor);
      return createCursor();
    };

    options = options || {};
    const defaultOptions = {
      timeSlowClass: "stop",
      containerSelector: ".container-typing",
      timeTypingMs: 55,
      timeSlow: 500,
      tagNamesToHide: ["LI"],
      callback: () => {},
    };

    options = { ...defaultOptions, ...options };

    const container = document.querySelector(options.containerSelector);

    if (!container) throw new Error("Property 'containerSelector' doesn't contains a valid element selector");

    if (typeof typingJS.executing == "undefined") typingJS.executing = false;

    const proxy = options.callback;

    options.callback = () => {
      typingJS.executing = false;
      proxy();
    };

    const cursorElement = getCursor();

    createStyle();

    const step1 = () => setClassDeepElements(container, options.tagNamesToHide);
    const step2 = () => processText(container);
    const step3 = () => processHiddenElements(cursorElement, options);

    const steps = [step1, step2, step3];

    const executeFn = () => {
      if (typingJS.executing) {
        console.warn("Already executing");
        return;
      }

      typingJS.executing = true;

      steps.forEach((stepFn) => stepFn());
    };
    return { execute: executeFn };
  }

  $parametersQtd = document.querySelector(".parametersQtd");
  $parameters = document.querySelector(".parameters");
  $image = document.querySelector(".image");

  $parametersQtd.classList.add("fade-in");
  typingJS({
    containerSelector: ".parametersQtd",
    callback: () => {
      $parameters.classList.add("fade-in");
      typingJS({
        containerSelector: ".parameters",
        callback: () => {
          $image.classList.add("fade-in");
        },
      }).execute();
    },
  }).execute();
</script>
