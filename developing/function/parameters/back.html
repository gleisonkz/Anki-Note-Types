<section>
  <header>
    <div>
      <p class="deckTree">{{Deck}}</p>
      <p class="subDeck">{{Subdeck}}</p>
    </div>
  </header>

  <article>
    <div class="questionField">
      <div>
        <span class="class-color cmd">Quais são os parâmetros</span>
        <span class="cmd">da função </span>
        <span id="questionField" class="functionColor">{{FunctionName}}()</span>?
      </div>
    </div>
  </article>

  <article class="articleAnswer hidden auto-hidden">
    <div class="notes">
      <div id="parameters" class="notesChild containerFlex" style="color: gray">{{Parameters}}</div>
    </div>
  </article>

  <article class="extraContainer fade-in">
    {{#SampleImage}}
    <div class="extra" id="extraField">
      <div class="notesChild">{{SampleImage}}</div>
    </div>
    {{/SampleImage}}
  </article>
  <footer>
    <audio style="display: none">{{ParametersAudio}}</audio>
  </footer>
</section>
<script>
  $("div:has(ul)", "div:has(ol)").addClass("notesChild");

  var regex = /(?<parameter>[^:]*): (?<type>[^-]*)- \[(?<description>.*?)\]/g;
  var element = document.getElementById("parameters");
  function addClass(element) {
    let elementHTML = element.innerHTML.replace(/&nbsp;/g, " ");
    const result = [...elementHTML.matchAll(regex)].map((item) => ({
      element: `<span>
                  <span class="attributeColorCSS">${item.groups.parameter}</span>: 
                  <span class="classColor">${item.groups.type}</span> - 
                  <span class="tagGrayColor">${item.groups.description}</span>
                  </span>`,
      fullMatch: item["0"],
    }));
    result.forEach((c) => {
      elementHTML = elementHTML.replace(c.fullMatch, c.element);
    });
    element.innerHTML = elementHTML;
  }
  addClass(element);
</script>
<script>
  var patterns = [
    {
      pattern: /(?<class>\w+)[.]\w+[.]\w+[(][)]/g,
      groupName: "class",
      className: "class-color",
    },
    {
      pattern: /(?<fix>\w+)[.]\w+[(][)]/g,
      groupName: "fix",
      className: "const-color",
    },
    {
      pattern: /(?<function>\w+)[(][)]/g,
      groupName: "function",
      className: "function-color",
    },
    {
      pattern: /(?<symbol>\?)/g,
      groupName: "symbol",
      className: "symbols-color",
    },
    {
      pattern: /(?<symbol>\!)/g,
      groupName: "symbol",
      className: "symbols-color",
    },
    {
      pattern: /(?<symbol>\()/g,
      groupName: "symbol",
      className: "symbols-color",
    },
    {
      pattern: /(?<symbol>\))/g,
      groupName: "symbol",
      className: "symbols-color",
    },
  ];

  function replaceStringAndAddClass(...elementsID) {
    elementsID.forEach((elementID) => {
      var element = document.getElementById(elementID);
      var textElement = element.innerHTML.trim();
      textElement = customReplace(textElement, patterns);
      element.innerHTML = textElement;
    });
  }

  function customReplace(textElement, matches) {
    matches.forEach((c) => {
      var matches = [...textElement.matchAll(c.pattern)];
      matches.forEach((match) => {
        var value = match.groups[c.groupName];
        textElement = textElement.replace(value, `<span class="${c.className}">${value}</span>`);
      });
    });
    return textElement;
  }

  replaceStringAndAddClass("questionField");

  var $question = document.querySelector("#parameters");
  var innerHTML = $question.innerHTML.trim();
  var targetText = customReplace(innerHTML, patterns);

  (function (root, factory) {
    if (typeof define === "function" && define.amd) {
      define(factory);
    } else if (typeof exports === "object") {
      module.exports = factory(require, exports, module);
    } else if (root) {
      root.TypeWriting = factory();
    } else {
      window.TypeWriting = factory();
    }
  })(this, (require, exports, module) => {
    "use strict";

    /**
     * the exported string position
     */
    let _currentNumber = 1;
    /**
     * whether is between a html tag
     */
    let _inHTMLTag = false;

    /**
     * plugin task status
     */
    const _taskStatus = {
      UNREADY: "UNREADY",
      READY: "READY",
      TYPEING: "TYPEING",
    };

    /**
     * the default config
     */
    let defaults = {
      targetElement: null,
      inputString: "",
      typingInterval: 150,
      blinkInterval: "0.7s",
      cursorColor: "black",
      pluginCallback: () => {},
      task: _taskStatus.UNREADY,
    };

    const _typingGo = () => {
      if (_currentNumber <= defaults.inputString.length) {
        const nextString = _sliceDisplayText(_currentNumber);
        _currentNumber += 1;

        if (nextString.slice(-1) === "<") {
          _inHTMLTag = true;
        } else if (nextString.slice(-1) === ">") {
          _inHTMLTag = false;
        }

        defaults.targetElement.innerHTML = nextString;

        if (_inHTMLTag) {
          _typingGo();
        } else {
          setTimeout(() => {
            _typingGo();
          }, defaults.typingInterval);
        }
      } else {
        defaults.task = _taskStatus.READY;
        _currentNumber = 1;
        defaults.pluginCallback.call();
      }
    };

    const _sliceDisplayText = (to) => defaults.inputString.slice(0, to);

    const _cleanCallback = () => {
      defaults.pluginCallback = () => {};
    };

    // Utility method to extend defaults with user options
    const extendDefaults = (source, properties) => {
      for (const property in properties) {
        if (properties.hasOwnProperty(property)) {
          source[property] = properties[property];
        }
      }
      return source;
    };

    /**
     * TypeWriting constructor
     */
    class TypeWriting {
      constructor(options, callbackFunction) {
        if (!options || typeof options !== "object") {
          throw new Error("`options` is invalid");
        }

        /**
         * check value from user
         * the string will be put in target later
         */
        if (!options.inputString) {
          throw new Error("Missing argument: inputString");
        }
        if (typeof options.inputString !== "string") {
          throw new Error("`inputString` is not a string");
        }

        /**
         * set the custom config
         */
        defaults = extendDefaults(defaults, options);

        /**
         * callback function
         */
        if (callbackFunction) {
          if (typeof callbackFunction === "function") {
            defaults.pluginCallback = callbackFunction;
          } else {
            console.error(`${callbackFunction} is not a function`);
            _cleanCallback();
          }
        } else {
          _cleanCallback();
        }

        /**
         * Calculate proper size of cursor
         * by inserting a new inline-element with `I`
         */
        const calcDiv = document.createElement("div");
        calcDiv.style.display = "inline-block";
        calcDiv.innerHTML = "I";
        defaults.targetElement.appendChild(calcDiv);
        const cursorHeight = calcDiv.offsetHeight;
        const cursorWidth = calcDiv.offsetWidth;
        defaults.targetElement.removeChild(calcDiv);

        /**
         * cursor css style
         */
        const cssStyle = `@-webkit-keyframes blink{0%,100%{opacity:1}50%{opacity:0}}@-moz-keyframes blink{0%,100%{opacity:1}50%{opacity:0}}@keyframes blink{0%,100%{opacity:1}50%{opacity:0}}.typingCursor::after{content:'';width:${cursorWidth}px;height:${cursorHeight}px;margin-left:5px;display:inline-block;vertical-align:bottom;background-color:${defaults.cursorColor};-webkit-animation:blink ${defaults.blinkInterval} infinite;-moz-animation:blink ${defaults.blinkInterval} infinite;animation:blink ${defaults.blinkInterval} infinite}`;

        /**
         * add CSS style in HEAD
         */
        const styleNode = document.createElement("style");
        styleNode.type = "text/css";
        if (styleNode.styleSheet) {
          styleNode.styleSheet.cssText = cssStyle;
        } else {
          styleNode.appendChild(document.createTextNode(cssStyle));
        }
        document.head.appendChild(styleNode);

        defaults.targetElement.className += " typingCursor";
        defaults.task = _taskStatus.TYPING;
        _typingGo();
      }

      /**
       * change the text on the same target
       */
      rewrite(inputString, callbackFunction) {
        if (defaults.task === _taskStatus.TYPING) {
          console.warn("Last task is not finished yet");
          setTimeout(() => {
            this.rewrite(inputString, callbackFunction);
          }, defaults.typingInterval);
          return;
        }

        /**
         * check value
         * the string will be put in target later
         */
        if (!inputString) {
          throw new Error("Missing argument: inputString");
        }
        if (typeof inputString !== "string") {
          throw new Error("`inputString` is not a string");
        }

        defaults.inputString = inputString;

        /**
         * callback function
         */
        if (callbackFunction) {
          if (typeof callbackFunction === "function") {
            defaults.pluginCallback = callbackFunction;
          } else {
            console.error(`${callbackFunction} is not a function`);
            _cleanCallback();
          }
        } else {
          _cleanCallback();
        }

        defaults.task = _taskStatus.TYPING;
        _typingGo();
      }
    }

    return TypeWriting;
  });

  new TypeWriting({
    targetElement: $question,
    inputString: targetText,
    typingInterval: 20,
    blinkInterval: "0.7s",
    cursorColor: "#00fd55",
  });
</script>
